// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addProductCategory = `-- name: AddProductCategory :exec
INSERT INTO product_categories (product_id, category_id)
VALUES ($1::bigint::integer, $2::integer)
ON CONFLICT (product_id, category_id) DO NOTHING
`

type AddProductCategoryParams struct {
	ProductID  string `json:"product_id"`
	CategoryID string `json:"category_id"`
}

func (q *Queries) AddProductCategory(ctx context.Context, arg AddProductCategoryParams) error {
	_, err := q.db.ExecContext(ctx, addProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories (name, slug, image, active)
VALUES ($1, $2, $3, $4)
RETURNING id::text as id, name, slug, image as image_url, active as is_active, created_at, updated_at
`

type CreateCategoryParams struct {
	Name     string         `json:"name"`
	Slug     string         `json:"slug"`
	ImageUrl sql.NullString `json:"image_url"`
	IsActive sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, createCategory,
		arg.Name,
		arg.Slug,
		arg.ImageUrl,
		arg.IsActive,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ImageUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGiftCard = `-- name: CreateGiftCard :one
INSERT INTO gift_cards (code, initial_balance, current_balance, expiry_date)
VALUES ($1, $2, $2, $3)
RETURNING id, code, initial_balance, current_balance, currency, status, expiry_date, created_at, updated_at
`

type CreateGiftCardParams struct {
	Code           string       `json:"code"`
	InitialBalance string       `json:"initial_balance"`
	ExpiryDate     sql.NullTime `json:"expiry_date"`
}

func (q *Queries) CreateGiftCard(ctx context.Context, arg CreateGiftCardParams) (GiftCard, error) {
	row := q.db.QueryRowContext(ctx, createGiftCard, arg.Code, arg.InitialBalance, arg.ExpiryDate)
	var i GiftCard
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.InitialBalance,
		&i.CurrentBalance,
		&i.Currency,
		&i.Status,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createGiftCardTransaction = `-- name: CreateGiftCardTransaction :one
INSERT INTO gift_card_transactions (gift_card_id, order_id, amount, type)
VALUES ($1, $2, $3, $4)
RETURNING id, gift_card_id, order_id, amount, type, created_at
`

type CreateGiftCardTransactionParams struct {
	GiftCardID uuid.UUID     `json:"gift_card_id"`
	OrderID    uuid.NullUUID `json:"order_id"`
	Amount     string        `json:"amount"`
	Type       string        `json:"type"`
}

func (q *Queries) CreateGiftCardTransaction(ctx context.Context, arg CreateGiftCardTransactionParams) (GiftCardTransaction, error) {
	row := q.db.QueryRowContext(ctx, createGiftCardTransaction,
		arg.GiftCardID,
		arg.OrderID,
		arg.Amount,
		arg.Type,
	)
	var i GiftCardTransaction
	err := row.Scan(
		&i.ID,
		&i.GiftCardID,
		&i.OrderID,
		&i.Amount,
		&i.Type,
		&i.CreatedAt,
	)
	return i, err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (customer_id, status, total_amount, payment_method)
VALUES ($1, $2, $3, $4)
RETURNING id, customer_id, status, total_amount, payment_method, order_number, created_at, updated_at
`

type CreateOrderParams struct {
	CustomerID    uuid.NullUUID  `json:"customer_id"`
	Status        string         `json:"status"`
	TotalAmount   string         `json:"total_amount"`
	PaymentMethod sql.NullString `json:"payment_method"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.CustomerID,
		arg.Status,
		arg.TotalAmount,
		arg.PaymentMethod,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.TotalAmount,
		&i.PaymentMethod,
		&i.OrderNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, variant_id, quantity, unit_price, subtotal)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, order_id, variant_id, quantity, unit_price, subtotal
`

type CreateOrderItemParams struct {
	OrderID   uuid.UUID `json:"order_id"`
	VariantID uuid.UUID `json:"variant_id"`
	Quantity  int32     `json:"quantity"`
	UnitPrice string    `json:"unit_price"`
	Subtotal  string    `json:"subtotal"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (OrderItem, error) {
	row := q.db.QueryRowContext(ctx, createOrderItem,
		arg.OrderID,
		arg.VariantID,
		arg.Quantity,
		arg.UnitPrice,
		arg.Subtotal,
	)
	var i OrderItem
	err := row.Scan(
		&i.ID,
		&i.OrderID,
		&i.VariantID,
		&i.Quantity,
		&i.UnitPrice,
		&i.Subtotal,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (name, description, base_price, category, image_url, is_active)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, name, description, base_price, category, image_url, is_active, created_at, updated_at
`

type CreateProductParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	BasePrice   string         `json:"base_price"`
	Category    sql.NullString `json:"category"`
	ImageUrl    sql.NullString `json:"image_url"`
	IsActive    sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, createProduct,
		arg.Name,
		arg.Description,
		arg.BasePrice,
		arg.Category,
		arg.ImageUrl,
		arg.IsActive,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BasePrice,
		&i.Category,
		&i.ImageUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductVariant = `-- name: CreateProductVariant :one
INSERT INTO product_variants (
  product_id, sku, size, color, image, stock_quantity
) VALUES (
  $1::bigint, $2, $3, $4, $5, $6
)
RETURNING 
  id, product_id, sku, size, color, image, stock_quantity, 
  stock_quantity as stock,
  CONCAT_WS(' / ', size, color)::text as name,
  created_at, updated_at
`

type CreateProductVariantParams struct {
	ProductID     string         `json:"product_id"`
	Sku           string         `json:"sku"`
	Size          sql.NullString `json:"size"`
	Color         sql.NullString `json:"color"`
	Image         sql.NullString `json:"image"`
	StockQuantity sql.NullInt32  `json:"stock_quantity"`
}

// Product Variant Mutations
func (q *Queries) CreateProductVariant(ctx context.Context, arg CreateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, createProductVariant,
		arg.ProductID,
		arg.Sku,
		arg.Size,
		arg.Color,
		arg.Image,
		arg.StockQuantity,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Size,
		&i.Color,
		&i.Image,
		&i.StockQuantity,
		&i.Stock,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, role)
VALUES ($1, $2, $3)
RETURNING id, email, password_hash, role, created_at, updated_at
`

type CreateUserParams struct {
	Email        string `json:"email"`
	PasswordHash string `json:"password_hash"`
	Role         string `json:"role"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Email, arg.PasswordHash, arg.Role)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = $1::bigint
`

func (q *Queries) DeleteCategory(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, id)
	return err
}

const deleteProduct = `-- name: DeleteProduct :exec
DELETE FROM products WHERE id = $1
`

func (q *Queries) DeleteProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteProduct, id)
	return err
}

const deleteProductVariant = `-- name: DeleteProductVariant :exec
DELETE FROM product_variants
WHERE id = $1::uuid
`

func (q *Queries) DeleteProductVariant(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProductVariant, id)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT id::text as id, name, slug, image as image_url, active as is_active, created_at, updated_at FROM categories WHERE id = $1::bigint LIMIT 1
`

func (q *Queries) GetCategory(ctx context.Context, id string) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ImageUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomer = `-- name: GetCustomer :one
SELECT id, first_name, last_name, email, phone, created_at FROM customers WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCustomer(ctx context.Context, id uuid.UUID) (Customer, error) {
	row := q.db.QueryRowContext(ctx, getCustomer, id)
	var i Customer
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
	)
	return i, err
}

const getGiftCardByCode = `-- name: GetGiftCardByCode :one
SELECT id, code, initial_balance, current_balance, currency, status, expiry_date, created_at, updated_at FROM gift_cards
WHERE code = $1 LIMIT 1
`

func (q *Queries) GetGiftCardByCode(ctx context.Context, code string) (GiftCard, error) {
	row := q.db.QueryRowContext(ctx, getGiftCardByCode, code)
	var i GiftCard
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.InitialBalance,
		&i.CurrentBalance,
		&i.Currency,
		&i.Status,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrder = `-- name: GetOrder :one
SELECT 
    o.id, 
    o.customer_id, 
    o.status, 
    o.total_amount, 
    o.payment_method, 
    o.order_number,
    o.created_at, 
    o.updated_at,
    c.first_name as customer_first_name,
    c.last_name as customer_last_name,
    c.email as customer_email,
    c.phone as customer_phone
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.id
WHERE o.id = $1 LIMIT 1
`

type GetOrderRow struct {
	ID                uuid.UUID      `json:"id"`
	CustomerID        uuid.NullUUID  `json:"customer_id"`
	Status            string         `json:"status"`
	TotalAmount       string         `json:"total_amount"`
	PaymentMethod     sql.NullString `json:"payment_method"`
	OrderNumber       int32          `json:"order_number"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	CustomerFirstName sql.NullString `json:"customer_first_name"`
	CustomerLastName  sql.NullString `json:"customer_last_name"`
	CustomerEmail     sql.NullString `json:"customer_email"`
	CustomerPhone     sql.NullString `json:"customer_phone"`
}

func (q *Queries) GetOrder(ctx context.Context, id uuid.UUID) (GetOrderRow, error) {
	row := q.db.QueryRowContext(ctx, getOrder, id)
	var i GetOrderRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.TotalAmount,
		&i.PaymentMethod,
		&i.OrderNumber,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomerFirstName,
		&i.CustomerLastName,
		&i.CustomerEmail,
		&i.CustomerPhone,
	)
	return i, err
}

const updateOrderStatus = `-- name: UpdateOrderStatus :one
UPDATE orders
SET status = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, customer_id, status, total_amount, payment_method, created_at, updated_at
`

type UpdateOrderStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status string    `json:"status"`
}

func (q *Queries) UpdateOrderStatus(ctx context.Context, arg UpdateOrderStatusParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrderStatus, arg.ID, arg.Status)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.TotalAmount,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProduct = `-- name: GetProduct :one
SELECT 
    p.id::text as id,
    p.title as name,
    p.description,
    COALESCE(min_price.price, p.base_price::text, '0')::text as base_price,
    ''::text as category,
    COALESCE(pi.url, p.thumbnail) as image_url,
    p.active as is_active,
    p.created_at,
    p.updated_at
FROM products p
LEFT JOIN LATERAL (
    SELECT MIN(pr.amount)::text as price
    FROM product_variants pv
    JOIN prices pr ON pr.variant_id = pv.id
    WHERE pv.product_id = p.id AND pv.active = true
) min_price ON true
LEFT JOIN LATERAL (
    SELECT url 
    FROM product_images 
    WHERE product_id = p.id 
    ORDER BY id 
    LIMIT 1
) pi ON true
WHERE p.id = $1::bigint LIMIT 1
`

func (q *Queries) GetProduct(ctx context.Context, id string) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProduct, id)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BasePrice,
		&i.Category,
		&i.ImageUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductBySlug = `-- name: GetProductBySlug :one
SELECT 
    p.id::text as id,
    p.title as name,
    p.slug,
    p.description,
    COALESCE(min_price.price, p.base_price::text, '0')::text as base_price,
    ''::text as category,
    COALESCE(pi.url, p.thumbnail) as image_url,
    p.active as is_active,
    p.created_at,
    p.updated_at
FROM products p
LEFT JOIN LATERAL (
    SELECT MIN(pr.amount)::text as price
    FROM product_variants pv
    JOIN prices pr ON pr.variant_id = pv.id
    WHERE pv.product_id = p.id AND pv.active = true
) min_price ON true
LEFT JOIN LATERAL (
    SELECT url 
    FROM product_images 
    WHERE product_id = p.id 
    ORDER BY id 
    LIMIT 1
) pi ON true
WHERE p.slug = $1 LIMIT 1
`

func (q *Queries) GetProductBySlug(ctx context.Context, slug string) (Product, error) {
	row := q.db.QueryRowContext(ctx, getProductBySlug, slug)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.BasePrice,
		&i.Category,
		&i.ImageUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductVariant = `-- name: GetProductVariant :one
SELECT 
  v.id, 
  v.product_id, 
  CONCAT_WS(' / ', v.size, v.color)::text as name, 
  v.sku, 
  v.size, 
  v.color, 
  v.image, 
  v.stock_quantity as stock, 
  v.stock_quantity, 
  NULL::boolean as active, 
  COALESCE(p.amount, 0) as price, 
  0 as display_order, 
  v.created_at, 
  v.updated_at
FROM product_variants v
LEFT JOIN prices p ON p.variant_id = v.id
WHERE v.id = $1::uuid LIMIT 1
`

func (q *Queries) GetProductVariant(ctx context.Context, id string) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, getProductVariant, id)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Name,
		&i.Sku,
		&i.Size,
		&i.Color,
		&i.Image,
		&i.Stock,
		&i.StockQuantity,
		&i.Active,
		&i.Price,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, role, created_at, updated_at FROM users
WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id::text as id, name, slug, image as image_url, active as is_active, created_at, updated_at FROM categories
WHERE active = true
ORDER BY name ASC
`

// Categories
func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ImageUrl,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerDetails = `-- name: GetCustomerDetails :one
SELECT 
    c.id, 
    c.first_name, 
    c.last_name, 
    c.email, 
    c.phone, 
    c.created_at,
    COUNT(o.id) as total_orders,
    COALESCE(SUM(o.total_amount), 0)::numeric(10,2) as total_spent,
    MAX(o.created_at) as last_order_date
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
WHERE c.id = $1
GROUP BY c.id
`

type GetCustomerDetailsRow struct {
	ID            uuid.UUID      `json:"id"`
	FirstName     sql.NullString `json:"first_name"`
	LastName      sql.NullString `json:"last_name"`
	Email         string         `json:"email"`
	Phone         sql.NullString `json:"phone"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	TotalOrders   int64          `json:"total_orders"`
	TotalSpent    string         `json:"total_spent"`
	LastOrderDate sql.NullTime   `json:"last_order_date"`
}

func (q *Queries) GetCustomerDetails(ctx context.Context, id uuid.UUID) (GetCustomerDetailsRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerDetails, id)
	var i GetCustomerDetailsRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.CreatedAt,
		&i.TotalOrders,
		&i.TotalSpent,
		&i.LastOrderDate,
	)
	return i, err
}

const listCustomerOrders = `-- name: ListCustomerOrders :many
SELECT id, status, total_amount, created_at 
FROM orders 
WHERE customer_id = $1 
ORDER BY created_at DESC
`

type ListCustomerOrdersRow struct {
	ID          uuid.UUID    `json:"id"`
	Status      string       `json:"status"`
	TotalAmount string       `json:"total_amount"`
	CreatedAt   sql.NullTime `json:"created_at"`
}

func (q *Queries) ListCustomerOrders(ctx context.Context, customerID uuid.NullUUID) ([]ListCustomerOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCustomerOrders, customerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCustomerOrdersRow
	for rows.Next() {
		var i ListCustomerOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.TotalAmount,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomers = `-- name: ListCustomers :many
SELECT 
    c.id, 
    c.first_name, 
    c.last_name, 
    c.email, 
    c.phone, 
    c.created_at,
    COUNT(o.id) as total_orders,
    COALESCE(SUM(o.total_amount), 0)::numeric(10,2) as total_spent,
    MAX(o.created_at) as last_order_date
FROM customers c
LEFT JOIN orders o ON c.id = o.customer_id
GROUP BY c.id
ORDER BY c.created_at DESC
`

type ListCustomersRow struct {
	ID            uuid.UUID      `json:"id"`
	FirstName     sql.NullString `json:"first_name"`
	LastName      sql.NullString `json:"last_name"`
	Email         string         `json:"email"`
	Phone         sql.NullString `json:"phone"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	TotalOrders   int64          `json:"total_orders"`
	TotalSpent    string         `json:"total_spent"`
	LastOrderDate sql.NullTime   `json:"last_order_date"`
}

// Customers
func (q *Queries) ListCustomers(ctx context.Context) ([]ListCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, listCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListCustomersRow
	for rows.Next() {
		var i ListCustomersRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Email,
			&i.Phone,
			&i.CreatedAt,
			&i.TotalOrders,
			&i.TotalSpent,
			&i.LastOrderDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrderItems = `-- name: ListOrderItems :many
SELECT 
    oi.id, 
    oi.order_id, 
    oi.variant_id, 
    oi.quantity, 
    oi.unit_price, 
    oi.subtotal,
    pv.sku,
    p.title as product_name,
    CONCAT_WS(' / ', pv.size, pv.color)::text as variant_name,
    COALESCE(pv.image, p.thumbnail) as image_url
FROM order_items oi
LEFT JOIN product_variants pv ON oi.variant_id = pv.id
LEFT JOIN products p ON pv.product_id = p.id
WHERE oi.order_id = $1
`

type ListOrderItemsRow struct {
	ID          uuid.UUID      `json:"id"`
	OrderID     uuid.UUID      `json:"order_id"`
	VariantID   uuid.UUID      `json:"variant_id"`
	Quantity    int32          `json:"quantity"`
	UnitPrice   string         `json:"unit_price"`
	Subtotal    string         `json:"subtotal"`
	Sku         sql.NullString `json:"sku"`
	ProductName sql.NullString `json:"product_name"`
	VariantName string         `json:"variant_name"`
	ImageUrl    sql.NullString `json:"image_url"`
}

func (q *Queries) ListOrderItems(ctx context.Context, orderID uuid.UUID) ([]ListOrderItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrderItems, orderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrderItemsRow
	for rows.Next() {
		var i ListOrderItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.OrderID,
			&i.VariantID,
			&i.Quantity,
			&i.UnitPrice,
			&i.Subtotal,
			&i.Sku,
			&i.ProductName,
			&i.VariantName,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOrders = `-- name: ListOrders :many
SELECT 
    o.id, 
    o.customer_id, 
    o.status, 
    o.total_amount, 
    o.payment_method, 
    o.order_number,
    o.created_at, 
    o.updated_at,
    c.first_name as customer_first_name,
    c.last_name as customer_last_name,
    c.email as customer_email
FROM orders o
LEFT JOIN customers c ON o.customer_id = c.id
ORDER BY o.created_at DESC
`

type ListOrdersRow struct {
	ID                uuid.UUID      `json:"id"`
	CustomerID        uuid.NullUUID  `json:"customer_id"`
	Status            string         `json:"status"`
	TotalAmount       string         `json:"total_amount"`
	PaymentMethod     sql.NullString `json:"payment_method"`
	OrderNumber       int32          `json:"order_number"`
	CreatedAt         sql.NullTime   `json:"created_at"`
	UpdatedAt         sql.NullTime   `json:"updated_at"`
	CustomerFirstName sql.NullString `json:"customer_first_name"`
	CustomerLastName  sql.NullString `json:"customer_last_name"`
	CustomerEmail     sql.NullString `json:"customer_email"`
}

// Orders
func (q *Queries) ListOrders(ctx context.Context) ([]ListOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOrdersRow
	for rows.Next() {
		var i ListOrdersRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.Status,
			&i.TotalAmount,
			&i.PaymentMethod,
			&i.OrderNumber,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomerFirstName,
			&i.CustomerLastName,
			&i.CustomerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductCategories = `-- name: ListProductCategories :many
SELECT c.id::text as id, c.name, c.slug, c.image as image_url, c.active as is_active, c.created_at, c.updated_at FROM categories c
JOIN product_categories pc ON c.id = pc.category_id
WHERE pc.product_id = $1::bigint
`

// Product Categories (Many-to-Many)
func (q *Queries) ListProductCategories(ctx context.Context, productID string) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, listProductCategories, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.ImageUrl,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductsByCategorySlug = `-- name: ListProductsByCategorySlug :many
SELECT 
    p.id::text as id,
    p.title as name,
    p.description,
    COALESCE(p.base_price, 0)::text as base_price,
    c.name as category,
    COALESCE(pi.url, p.thumbnail) as image_url,
    p.active as is_active,
    p.created_at,
    p.updated_at
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
LEFT JOIN LATERAL (
    SELECT url 
    FROM product_images 
    WHERE product_id = p.id 
    ORDER BY id 
    LIMIT 1
) pi ON true
WHERE c.slug = $1 AND p.active = true
ORDER BY p.created_at DESC
LIMIT $2 OFFSET $3
`

type ListProductsRow struct {
	ID          string         `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	BasePrice   string         `json:"base_price"`
	Category    sql.NullString `json:"category"`
	ImageUrl    sql.NullString `json:"image_url"`
	IsActive    sql.NullBool   `json:"is_active"`
	CreatedAt   sql.NullTime   `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
}

type ListProductsByCategorySlugParams struct {
	Slug   string
	Limit  int32
	Offset int32
}

func (q *Queries) ListProductsByCategorySlug(ctx context.Context, arg ListProductsByCategorySlugParams) ([]ListProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProductsByCategorySlug, arg.Slug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProductsRow
	for rows.Next() {
		var i ListProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.BasePrice,
			&i.Category,
			&i.ImageUrl,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProductImages = `-- name: ListProductImages :many
SELECT id, product_id, url, created_at FROM product_images
WHERE product_id = $1::bigint
`

func (q *Queries) ListProductImages(ctx context.Context, productID string) ([]ProductImage, error) {
	rows, err := q.db.QueryContext(ctx, listProductImages, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductImage
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Url,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addProductImage = `-- name: AddProductImage :one
INSERT INTO product_images (product_id, url, position)
VALUES ($1::bigint, $2, $3)
RETURNING id::text, product_id::text, url, created_at
`

type AddProductImageParams struct {
	ProductID string `json:"product_id"`
	Url       string `json:"url"`
	Position  int64  `json:"position"`
}

func (q *Queries) AddProductImage(ctx context.Context, arg AddProductImageParams) (ProductImage, error) {
	row := q.db.QueryRowContext(ctx, addProductImage, arg.ProductID, arg.Url, arg.Position)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Url,
		&i.CreatedAt,
	)
	return i, err
}

const deleteProductImage = `-- name: DeleteProductImage :exec
DELETE FROM product_images WHERE id = $1::bigint
`

func (q *Queries) DeleteProductImage(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteProductImage, id)
	return err
}

const listProductVariants = `-- name: ListProductVariants :many
SELECT 
  v.id, 
  v.product_id, 
  CONCAT_WS(' / ', v.size, v.color)::text as name, 
  v.sku, 
  v.size, 
  v.color, 
  v.image, 
  v.stock_quantity as stock, 
  v.stock_quantity, 
  NULL::boolean as active, 
  COALESCE(p.amount, 0) as price, 
  0 as display_order, 
  v.created_at, 
  v.updated_at
FROM product_variants v
LEFT JOIN prices p ON p.variant_id = v.id
WHERE v.product_id = $1::bigint
ORDER BY v.created_at ASC
`

func (q *Queries) ListProductVariants(ctx context.Context, productID string) ([]ProductVariant, error) {
	rows, err := q.db.QueryContext(ctx, listProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProductVariant
	for rows.Next() {
		var i ProductVariant
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Name,
			&i.Sku,
			&i.Size,
			&i.Color,
			&i.Image,
			&i.Stock,
			&i.StockQuantity,
			&i.Active,
			&i.Price,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT 
    p.id::text as id,
    p.title as name,
    p.slug,
    p.description,
    COALESCE(p.base_price, 0)::text as base_price,
    ''::text as category,
    COALESCE(pi.url, p.thumbnail) as image_url,
    p.active as is_active,
    p.created_at,
    p.updated_at
FROM products p
LEFT JOIN LATERAL (
    SELECT url 
    FROM product_images 
    WHERE product_id = p.id 
    ORDER BY position ASC
    LIMIT 1
) pi ON true
WHERE p.active = true
ORDER BY p.created_at DESC NULLS LAST, p.id DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.QueryContext(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.BasePrice,
			&i.Category,
			&i.ImageUrl,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProductCategory = `-- name: RemoveProductCategory :exec
DELETE FROM product_categories
WHERE product_id = $1 AND category_id = $2
`

type RemoveProductCategoryParams struct {
	ProductID  uuid.UUID `json:"product_id"`
	CategoryID uuid.UUID `json:"category_id"`
}

func (q *Queries) RemoveProductCategory(ctx context.Context, arg RemoveProductCategoryParams) error {
	_, err := q.db.ExecContext(ctx, removeProductCategory, arg.ProductID, arg.CategoryID)
	return err
}

const setProductCategories = `-- name: SetProductCategories :exec
DELETE FROM product_categories WHERE product_id = $1::bigint::integer
`

func (q *Queries) SetProductCategories(ctx context.Context, productID string) error {
	_, err := q.db.ExecContext(ctx, setProductCategories, productID)
	return err
}

const updateCategory = `-- name: UpdateCategory :one
UPDATE categories
SET name = $2, slug = $3, image = $4, active = $5, updated_at = NOW()
WHERE id = $1::bigint
RETURNING id::text as id, name, slug, image as image_url, active as is_active, created_at, updated_at
`

type UpdateCategoryParams struct {
	ID       string         `json:"id"`
	Name     string         `json:"name"`
	Slug     string         `json:"slug"`
	ImageUrl sql.NullString `json:"image_url"`
	IsActive sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) (Category, error) {
	row := q.db.QueryRowContext(ctx, updateCategory,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.ImageUrl,
		arg.IsActive,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.ImageUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateGiftCardBalance = `-- name: UpdateGiftCardBalance :one
UPDATE gift_cards
SET current_balance = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, code, initial_balance, current_balance, currency, status, expiry_date, created_at, updated_at
`

type UpdateGiftCardBalanceParams struct {
	ID             uuid.UUID `json:"id"`
	CurrentBalance string    `json:"current_balance"`
}

func (q *Queries) UpdateGiftCardBalance(ctx context.Context, arg UpdateGiftCardBalanceParams) (GiftCard, error) {
	row := q.db.QueryRowContext(ctx, updateGiftCardBalance, arg.ID, arg.CurrentBalance)
	var i GiftCard
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.InitialBalance,
		&i.CurrentBalance,
		&i.Currency,
		&i.Status,
		&i.ExpiryDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrder = `-- name: UpdateOrder :one
UPDATE orders
SET status = $2, payment_method = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, customer_id, status, total_amount, payment_method, created_at, updated_at
`

type UpdateOrderParams struct {
	ID            uuid.UUID      `json:"id"`
	Status        string         `json:"status"`
	PaymentMethod sql.NullString `json:"payment_method"`
}

func (q *Queries) UpdateOrder(ctx context.Context, arg UpdateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrder, arg.ID, arg.Status, arg.PaymentMethod)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.Status,
		&i.TotalAmount,
		&i.PaymentMethod,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET name = $2, description = $3, base_price = $4, category = $5, image_url = $6, is_active = $7, updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, base_price, category, image_url, is_active, created_at, updated_at
`

type UpdateProductParams struct {
	ID          uuid.UUID      `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	BasePrice   string         `json:"base_price"`
	Category    sql.NullString `json:"category"`
	ImageUrl    sql.NullString `json:"image_url"`
	IsActive    sql.NullBool   `json:"is_active"`
}

// Product Mutations
func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRowContext(ctx, updateProduct,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.BasePrice,
		arg.Category,
		arg.ImageUrl,
		arg.IsActive,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.BasePrice,
		&i.Category,
		&i.ImageUrl,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductVariant = `-- name: UpdateProductVariant :one
UPDATE product_variants
SET 
  sku = $2,
  size = $3,
  color = $4,
  image = $5,
  stock_quantity = $6,
  updated_at = NOW()
WHERE id = $1::uuid
RETURNING 
  id, product_id, sku, size, color, image, stock_quantity, 
  stock_quantity as stock,
  CONCAT_WS(' / ', size, color)::text as name,
  created_at, updated_at
`

type UpdateProductVariantParams struct {
	ID            string         `json:"id"`
	Sku           string         `json:"sku"`
	Size          sql.NullString `json:"size"`
	Color         sql.NullString `json:"color"`
	Image         sql.NullString `json:"image"`
	StockQuantity sql.NullInt32  `json:"stock_quantity"`
}

func (q *Queries) UpdateProductVariant(ctx context.Context, arg UpdateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRowContext(ctx, updateProductVariant,
		arg.ID,
		arg.Sku,
		arg.Size,
		arg.Color,
		arg.Image,
		arg.StockQuantity,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Size,
		&i.Color,
		&i.Image,
		&i.StockQuantity,
		&i.Stock,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateVariantStock = `-- name: UpdateVariantStock :exec
UPDATE product_variants
SET stock_quantity = stock_quantity - $2
WHERE id = $1
`

type UpdateVariantStockParams struct {
	ID    uuid.UUID `json:"id"`
	Stock int32     `json:"stock"`
}

func (q *Queries) UpdateVariantStock(ctx context.Context, arg UpdateVariantStockParams) error {
	_, err := q.db.ExecContext(ctx, updateVariantStock, arg.ID, arg.Stock)
	return err
}

type Coupon struct {
	ID                   int64          `json:"id"`
	Code                 string         `json:"code"`
	Type                 string         `json:"type"`
	Value                string         `json:"value"`
	MinOrderValue        sql.NullString `json:"min_order_value"`
	MaxDiscount          sql.NullString `json:"max_discount"`
	UsageLimit           sql.NullInt32  `json:"usage_limit"`
	UsageCount           sql.NullInt32  `json:"usage_count"`
	SingleUsePerCustomer sql.NullBool   `json:"single_use_per_customer"`
	ApplicableProducts   []int64        `json:"applicable_products"`
	ApplicableCategories []int64        `json:"applicable_categories"`
	StartsAt             sql.NullTime   `json:"starts_at"`
	ExpiresAt            sql.NullTime   `json:"expires_at"`
	IsActive             sql.NullBool   `json:"is_active"`
	CreatedBy            sql.NullInt64  `json:"created_by"`
	CreatedAt            sql.NullTime   `json:"created_at"`
	UpdatedAt            sql.NullTime   `json:"updated_at"`
}

const createCoupon = `-- name: CreateCoupon :one
INSERT INTO coupons (
  code, type, value, min_order_value, max_discount, 
  usage_limit, starts_at, expires_at, is_active
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, code, type, value, min_order_value, max_discount, usage_limit, usage_count, single_use_per_customer, applicable_products, applicable_categories, starts_at, expires_at, is_active, created_by, created_at, updated_at
`

type CreateCouponParams struct {
	Code          string         `json:"code"`
	Type          string         `json:"type"`
	Value         string         `json:"value"`
	MinOrderValue sql.NullString `json:"min_order_value"`
	MaxDiscount   sql.NullString `json:"max_discount"`
	UsageLimit    sql.NullInt32  `json:"usage_limit"`
	StartsAt      sql.NullTime   `json:"starts_at"`
	ExpiresAt     sql.NullTime   `json:"expires_at"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) CreateCoupon(ctx context.Context, arg CreateCouponParams) (Coupon, error) {
	row := q.db.QueryRowContext(ctx, createCoupon,
		arg.Code,
		arg.Type,
		arg.Value,
		arg.MinOrderValue,
		arg.MaxDiscount,
		arg.UsageLimit,
		arg.StartsAt,
		arg.ExpiresAt,
		arg.IsActive,
	)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinOrderValue,
		&i.MaxDiscount,
		&i.UsageLimit,
		&i.UsageCount,
		&i.SingleUsePerCustomer,
		pq.Array(&i.ApplicableProducts),
		pq.Array(&i.ApplicableCategories),
		&i.StartsAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCoupon = `-- name: DeleteCoupon :exec
DELETE FROM coupons
WHERE id = $1
`

func (q *Queries) DeleteCoupon(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCoupon, id)
	return err
}

type StoreSetting struct {
	ID         int32          `json:"id"`
	StoreName  string         `json:"store_name"`
	StoreEmail sql.NullString `json:"store_email"`
	StorePhone sql.NullString `json:"store_phone"`
	Currency   sql.NullString `json:"currency"`
	UpdatedAt  sql.NullTime   `json:"updated_at"`
}

const getStoreSettings = `-- name: GetStoreSettings :one
SELECT id, store_name, store_email, store_phone, currency, updated_at FROM store_settings LIMIT 1
`

func (q *Queries) GetStoreSettings(ctx context.Context) (StoreSetting, error) {
	row := q.db.QueryRowContext(ctx, getStoreSettings)
	var i StoreSetting
	err := row.Scan(
		&i.ID,
		&i.StoreName,
		&i.StoreEmail,
		&i.StorePhone,
		&i.Currency,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStoreSettings = `-- name: UpdateStoreSettings :one
UPDATE store_settings
SET 
  store_name = $1,
  store_email = $2,
  store_phone = $3,
  currency = $4,
  updated_at = CURRENT_TIMESTAMP
RETURNING id, store_name, store_email, store_phone, currency, updated_at
`

type UpdateStoreSettingsParams struct {
	StoreName  string         `json:"store_name"`
	StoreEmail sql.NullString `json:"store_email"`
	StorePhone sql.NullString `json:"store_phone"`
	Currency   sql.NullString `json:"currency"`
}

func (q *Queries) UpdateStoreSettings(ctx context.Context, arg UpdateStoreSettingsParams) (StoreSetting, error) {
	row := q.db.QueryRowContext(ctx, updateStoreSettings,
		arg.StoreName,
		arg.StoreEmail,
		arg.StorePhone,
		arg.Currency,
	)
	var i StoreSetting
	err := row.Scan(
		&i.ID,
		&i.StoreName,
		&i.StoreEmail,
		&i.StorePhone,
		&i.Currency,
		&i.UpdatedAt,
	)
	return i, err
}

const listAdminUsers = `-- name: ListAdminUsers :many
SELECT id, email, first_name, last_name, role, is_active, last_login, created_at 
FROM admin_users
ORDER BY created_at DESC
`

type ListAdminUsersRow struct {
	ID        int64          `json:"id"`
	Email     string         `json:"email"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	Role      string         `json:"role"`
	IsActive  sql.NullBool   `json:"is_active"`
	LastLogin sql.NullTime   `json:"last_login"`
	CreatedAt sql.NullTime   `json:"created_at"`
}

func (q *Queries) ListAdminUsers(ctx context.Context) ([]ListAdminUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, listAdminUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAdminUsersRow
	for rows.Next() {
		var i ListAdminUsersRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.FirstName,
			&i.LastName,
			&i.Role,
			&i.IsActive,
			&i.LastLogin,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createAdminUser = `-- name: CreateAdminUser :one
INSERT INTO admin_users (
  email, password_hash, first_name, last_name, role, is_active
) VALUES (
  $1, $2, $3, $4, $5, $6
)
RETURNING id, email, first_name, last_name, role, is_active, created_at
`

type CreateAdminUserParams struct {
	Email        string         `json:"email"`
	PasswordHash string         `json:"password_hash"`
	FirstName    sql.NullString `json:"first_name"`
	LastName     sql.NullString `json:"last_name"`
	Role         string         `json:"role"`
	IsActive     sql.NullBool   `json:"is_active"`
}

type CreateAdminUserRow struct {
	ID        int64          `json:"id"`
	Email     string         `json:"email"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	Role      string         `json:"role"`
	IsActive  sql.NullBool   `json:"is_active"`
	CreatedAt sql.NullTime   `json:"created_at"`
}

func (q *Queries) CreateAdminUser(ctx context.Context, arg CreateAdminUserParams) (CreateAdminUserRow, error) {
	row := q.db.QueryRowContext(ctx, createAdminUser,
		arg.Email,
		arg.PasswordHash,
		arg.FirstName,
		arg.LastName,
		arg.Role,
		arg.IsActive,
	)
	var i CreateAdminUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.IsActive,
		&i.CreatedAt,
	)
	return i, err
}

const updateAdminUser = `-- name: UpdateAdminUser :one
UPDATE admin_users
SET 
  first_name = $2,
  last_name = $3,
  role = $4,
  is_active = $5,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, email, first_name, last_name, role, is_active, updated_at
`

type UpdateAdminUserParams struct {
	ID        int64          `json:"id"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	Role      string         `json:"role"`
	IsActive  sql.NullBool   `json:"is_active"`
}

type UpdateAdminUserRow struct {
	ID        int64          `json:"id"`
	Email     string         `json:"email"`
	FirstName sql.NullString `json:"first_name"`
	LastName  sql.NullString `json:"last_name"`
	Role      string         `json:"role"`
	IsActive  sql.NullBool   `json:"is_active"`
	UpdatedAt sql.NullTime   `json:"updated_at"`
}

func (q *Queries) UpdateAdminUser(ctx context.Context, arg UpdateAdminUserParams) (UpdateAdminUserRow, error) {
	row := q.db.QueryRowContext(ctx, updateAdminUser,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.Role,
		arg.IsActive,
	)
	var i UpdateAdminUserRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Role,
		&i.IsActive,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAdminPassword = `-- name: UpdateAdminPassword :exec
UPDATE admin_users
SET password_hash = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateAdminPasswordParams struct {
	ID           int64  `json:"id"`
	PasswordHash string `json:"password_hash"`
}

func (q *Queries) UpdateAdminPassword(ctx context.Context, arg UpdateAdminPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminPassword, arg.ID, arg.PasswordHash)
	return err
}

const deleteAdminUser = `-- name: DeleteAdminUser :exec
DELETE FROM admin_users
WHERE id = $1
`

func (q *Queries) DeleteAdminUser(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteAdminUser, id)
	return err
}

type InventoryMovement struct {
	ID            uuid.UUID      `json:"id"`
	VariantID     uuid.NullUUID  `json:"variant_id"`
	Type          string         `json:"type"`
	Quantity      int32          `json:"quantity"`
	PreviousStock int32          `json:"previous_stock"`
	NewStock      int32          `json:"new_stock"`
	ReferenceID   sql.NullString `json:"reference_id"`
	Note          sql.NullString `json:"note"`
	UserID        sql.NullInt64  `json:"user_id"`
	CreatedAt     sql.NullTime   `json:"created_at"`
}

const createInventoryMovement = `-- name: CreateInventoryMovement :one
INSERT INTO inventory_movements (
  variant_id, type, quantity, previous_stock, new_stock, reference_id, note, user_id
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, variant_id, type, quantity, previous_stock, new_stock, reference_id, note, user_id, created_at
`

type CreateInventoryMovementParams struct {
	VariantID     uuid.NullUUID  `json:"variant_id"`
	Type          string         `json:"type"`
	Quantity      int32          `json:"quantity"`
	PreviousStock int32          `json:"previous_stock"`
	NewStock      int32          `json:"new_stock"`
	ReferenceID   sql.NullString `json:"reference_id"`
	Note          sql.NullString `json:"note"`
	UserID        sql.NullInt64  `json:"user_id"`
}

func (q *Queries) CreateInventoryMovement(ctx context.Context, arg CreateInventoryMovementParams) (InventoryMovement, error) {
	row := q.db.QueryRowContext(ctx, createInventoryMovement,
		arg.VariantID,
		arg.Type,
		arg.Quantity,
		arg.PreviousStock,
		arg.NewStock,
		arg.ReferenceID,
		arg.Note,
		arg.UserID,
	)
	var i InventoryMovement
	err := row.Scan(
		&i.ID,
		&i.VariantID,
		&i.Type,
		&i.Quantity,
		&i.PreviousStock,
		&i.NewStock,
		&i.ReferenceID,
		&i.Note,
		&i.UserID,
		&i.CreatedAt,
	)
	return i, err
}

const listInventoryMovements = `-- name: ListInventoryMovements :many
SELECT im.id, im.variant_id, im.type, im.quantity, im.previous_stock, im.new_stock, im.reference_id, im.note, im.user_id, im.created_at, v.sku, p.title as product_name, u.email as user_email
FROM inventory_movements im
JOIN variants v ON im.variant_id = v.id
JOIN products p ON v.product_id = p.id
LEFT JOIN admin_users u ON im.user_id = u.id
ORDER BY im.created_at DESC
LIMIT $1 OFFSET $2
`

type ListInventoryMovementsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListInventoryMovementsRow struct {
	ID            int32          `json:"id"`
	VariantID     sql.NullInt64  `json:"variant_id"`
	Type          string         `json:"type"`
	Quantity      int32          `json:"quantity"`
	PreviousStock int32          `json:"previous_stock"`
	NewStock      int32          `json:"new_stock"`
	ReferenceID   sql.NullString `json:"reference_id"`
	Note          sql.NullString `json:"note"`
	UserID        sql.NullInt64  `json:"user_id"`
	CreatedAt     sql.NullTime   `json:"created_at"`
	Sku           string         `json:"sku"`
	ProductName   string         `json:"product_name"`
	UserEmail     sql.NullString `json:"user_email"`
}

func (q *Queries) ListInventoryMovements(ctx context.Context, arg ListInventoryMovementsParams) ([]ListInventoryMovementsRow, error) {
	rows, err := q.db.QueryContext(ctx, listInventoryMovements, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInventoryMovementsRow
	for rows.Next() {
		var i ListInventoryMovementsRow
		if err := rows.Scan(
			&i.ID,
			&i.VariantID,
			&i.Type,
			&i.Quantity,
			&i.PreviousStock,
			&i.NewStock,
			&i.ReferenceID,
			&i.Note,
			&i.UserID,
			&i.CreatedAt,
			&i.Sku,
			&i.ProductName,
			&i.UserEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLowStockVariants = `-- name: GetLowStockVariants :many
SELECT v.id, v.sku, v.stock_quantity, p.title as product_name, p.image_url
FROM variants v
JOIN products p ON v.product_id = p.id
WHERE v.stock_quantity < $1
ORDER BY v.stock_quantity ASC
`

type GetLowStockVariantsRow struct {
	ID            int64          `json:"id"`
	Sku           string         `json:"sku"`
	StockQuantity int32          `json:"stock_quantity"`
	ProductName   string         `json:"product_name"`
	ImageUrl      sql.NullString `json:"image_url"`
}

func (q *Queries) GetLowStockVariants(ctx context.Context, stockQuantity int32) ([]GetLowStockVariantsRow, error) {
	rows, err := q.db.QueryContext(ctx, getLowStockVariants, stockQuantity)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLowStockVariantsRow
	for rows.Next() {
		var i GetLowStockVariantsRow
		if err := rows.Scan(
			&i.ID,
			&i.Sku,
			&i.StockQuantity,
			&i.ProductName,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInventoryStats = `-- name: GetInventoryStats :one
SELECT 
  COUNT(*) FILTER (WHERE stock_quantity < 1) as low_stock_count,
  COALESCE(SUM(stock_quantity), 0)::bigint as total_stock_items
FROM variants
`

type GetInventoryStatsRow struct {
	LowStockCount   int64 `json:"low_stock_count"`
	TotalStockItems int64 `json:"total_stock_items"`
}

func (q *Queries) GetInventoryStats(ctx context.Context) (GetInventoryStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getInventoryStats)
	var i GetInventoryStatsRow
	err := row.Scan(&i.LowStockCount, &i.TotalStockItems)
	return i, err
}

const getSalesAnalytics = `-- name: GetSalesAnalytics :one
SELECT 
  COUNT(DISTINCT o.id) as total_orders,
  COALESCE(SUM(o.total_amount), 0)::bigint as total_revenue,
  COALESCE(AVG(o.total_amount), 0)::bigint as average_order_value,
  COUNT(DISTINCT o.customer_id) as unique_customers
FROM orders o
WHERE o.created_at >= $1 AND o.created_at <= $2
`

type GetSalesAnalyticsParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetSalesAnalyticsRow struct {
	TotalOrders       int64 `json:"total_orders"`
	TotalRevenue      int64 `json:"total_revenue"`
	AverageOrderValue int64 `json:"average_order_value"`
	UniqueCustomers   int64 `json:"unique_customers"`
}

func (q *Queries) GetSalesAnalytics(ctx context.Context, arg GetSalesAnalyticsParams) (GetSalesAnalyticsRow, error) {
	row := q.db.QueryRowContext(ctx, getSalesAnalytics, arg.CreatedAt, arg.CreatedAt_2)
	var i GetSalesAnalyticsRow
	err := row.Scan(
		&i.TotalOrders,
		&i.TotalRevenue,
		&i.AverageOrderValue,
		&i.UniqueCustomers,
	)
	return i, err
}

const getTopSellingProducts = `-- name: GetTopSellingProducts :many
SELECT 
  p.id,
  p.title as product_name,
  p.image_url,
  COUNT(oi.id) as order_count,
  COALESCE(SUM(oi.quantity), 0)::bigint as total_quantity_sold,
  COALESCE(SUM(oi.price * oi.quantity), 0)::bigint as total_revenue
FROM products p
JOIN variants v ON p.id = v.product_id
JOIN order_items oi ON v.id = oi.variant_id
JOIN orders o ON oi.order_id = o.id
WHERE o.created_at >= $1 AND o.created_at <= $2
GROUP BY p.id, p.title, p.image_url
ORDER BY total_revenue DESC
LIMIT $3
`

type GetTopSellingProductsParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
	Limit       int32     `json:"limit"`
}

type GetTopSellingProductsRow struct {
	ID                int64          `json:"id"`
	ProductName       string         `json:"product_name"`
	ImageUrl          sql.NullString `json:"image_url"`
	OrderCount        int64          `json:"order_count"`
	TotalQuantitySold int64          `json:"total_quantity_sold"`
	TotalRevenue      int64          `json:"total_revenue"`
}

func (q *Queries) GetTopSellingProducts(ctx context.Context, arg GetTopSellingProductsParams) ([]GetTopSellingProductsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTopSellingProducts, arg.CreatedAt, arg.CreatedAt_2, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopSellingProductsRow
	for rows.Next() {
		var i GetTopSellingProductsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductName,
			&i.ImageUrl,
			&i.OrderCount,
			&i.TotalQuantitySold,
			&i.TotalRevenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerMetrics = `-- name: GetCustomerMetrics :one
SELECT 
  COUNT(DISTINCT customer_id) as total_customers,
  COUNT(DISTINCT CASE WHEN order_count > 1 THEN customer_id END) as repeat_customers,
  COALESCE(AVG(order_count), 0) as avg_orders_per_customer
FROM (
  SELECT customer_id, COUNT(*) as order_count
  FROM orders
  WHERE created_at >= $1 AND created_at <= $2
  GROUP BY customer_id
) customer_orders
`

type GetCustomerMetricsParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetCustomerMetricsRow struct {
	TotalCustomers       int64   `json:"total_customers"`
	RepeatCustomers      int64   `json:"repeat_customers"`
	AvgOrdersPerCustomer float64 `json:"avg_orders_per_customer"`
}

func (q *Queries) GetCustomerMetrics(ctx context.Context, arg GetCustomerMetricsParams) (GetCustomerMetricsRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerMetrics, arg.CreatedAt, arg.CreatedAt_2)
	var i GetCustomerMetricsRow
	err := row.Scan(
		&i.TotalCustomers,
		&i.RepeatCustomers,
		&i.AvgOrdersPerCustomer,
	)
	return i, err
}

const getRevenueByDate = `-- name: GetRevenueByDate :many
SELECT 
  DATE(created_at) as date,
  COUNT(*) as order_count,
  COALESCE(SUM(total_amount), 0)::bigint as revenue
FROM orders
WHERE created_at >= $1 AND created_at <= $2
GROUP BY DATE(created_at)
ORDER BY date ASC
`

type GetRevenueByDateParams struct {
	CreatedAt   time.Time `json:"created_at"`
	CreatedAt_2 time.Time `json:"created_at_2"`
}

type GetRevenueByDateRow struct {
	Date       time.Time `json:"date"`
	OrderCount int64     `json:"order_count"`
	Revenue    int64     `json:"revenue"`
}

func (q *Queries) GetRevenueByDate(ctx context.Context, arg GetRevenueByDateParams) ([]GetRevenueByDateRow, error) {
	rows, err := q.db.QueryContext(ctx, getRevenueByDate, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRevenueByDateRow
	for rows.Next() {
		var i GetRevenueByDateRow
		if err := rows.Scan(
			&i.Date,
			&i.OrderCount,
			&i.Revenue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCoupon = `-- name: GetCoupon :one
SELECT id, code, type, value, min_order_value, max_discount, usage_limit, usage_count, single_use_per_customer, applicable_products, applicable_categories, starts_at, expires_at, is_active, created_by, created_at, updated_at FROM coupons
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetCoupon(ctx context.Context, id int64) (Coupon, error) {
	row := q.db.QueryRowContext(ctx, getCoupon, id)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinOrderValue,
		&i.MaxDiscount,
		&i.UsageLimit,
		&i.UsageCount,
		&i.SingleUsePerCustomer,
		pq.Array(&i.ApplicableProducts),
		pq.Array(&i.ApplicableCategories),
		&i.StartsAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCouponByCode = `-- name: GetCouponByCode :one
SELECT id, code, type, value, min_order_value, max_discount, usage_limit, usage_count, single_use_per_customer, applicable_products, applicable_categories, starts_at, expires_at, is_active, created_by, created_at, updated_at FROM coupons
WHERE code = $1 LIMIT 1
`

func (q *Queries) GetCouponByCode(ctx context.Context, code string) (Coupon, error) {
	row := q.db.QueryRowContext(ctx, getCouponByCode, code)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinOrderValue,
		&i.MaxDiscount,
		&i.UsageLimit,
		&i.UsageCount,
		&i.SingleUsePerCustomer,
		pq.Array(&i.ApplicableProducts),
		pq.Array(&i.ApplicableCategories),
		&i.StartsAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCoupons = `-- name: ListCoupons :many
SELECT id, code, type, value, min_order_value, max_discount, usage_limit, usage_count, single_use_per_customer, applicable_products, applicable_categories, starts_at, expires_at, is_active, created_by, created_at, updated_at FROM coupons
ORDER BY created_at DESC
`

func (q *Queries) ListCoupons(ctx context.Context) ([]Coupon, error) {
	rows, err := q.db.QueryContext(ctx, listCoupons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Coupon
	for rows.Next() {
		var i Coupon
		if err := rows.Scan(
			&i.ID,
			&i.Code,
			&i.Type,
			&i.Value,
			&i.MinOrderValue,
			&i.MaxDiscount,
			&i.UsageLimit,
			&i.UsageCount,
			&i.SingleUsePerCustomer,
			pq.Array(&i.ApplicableProducts),
			pq.Array(&i.ApplicableCategories),
			&i.StartsAt,
			&i.ExpiresAt,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCoupon = `-- name: UpdateCoupon :one
UPDATE coupons
SET 
  code = $2,
  type = $3,
  value = $4,
  min_order_value = $5,
  max_discount = $6,
  usage_limit = $7,
  starts_at = $8,
  expires_at = $9,
  is_active = $10,
  updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, code, type, value, min_order_value, max_discount, usage_limit, usage_count, single_use_per_customer, applicable_products, applicable_categories, starts_at, expires_at, is_active, created_by, created_at, updated_at
`

type UpdateCouponParams struct {
	ID            int64          `json:"id"`
	Code          string         `json:"code"`
	Type          string         `json:"type"`
	Value         string         `json:"value"`
	MinOrderValue sql.NullString `json:"min_order_value"`
	MaxDiscount   sql.NullString `json:"max_discount"`
	UsageLimit    sql.NullInt32  `json:"usage_limit"`
	StartsAt      sql.NullTime   `json:"starts_at"`
	ExpiresAt     sql.NullTime   `json:"expires_at"`
	IsActive      sql.NullBool   `json:"is_active"`
}

func (q *Queries) UpdateCoupon(ctx context.Context, arg UpdateCouponParams) (Coupon, error) {
	row := q.db.QueryRowContext(ctx, updateCoupon,
		arg.ID,
		arg.Code,
		arg.Type,
		arg.Value,
		arg.MinOrderValue,
		arg.MaxDiscount,
		arg.UsageLimit,
		arg.StartsAt,
		arg.ExpiresAt,
		arg.IsActive,
	)
	var i Coupon
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.Type,
		&i.Value,
		&i.MinOrderValue,
		&i.MaxDiscount,
		&i.UsageLimit,
		&i.UsageCount,
		&i.SingleUsePerCustomer,
		pq.Array(&i.ApplicableProducts),
		pq.Array(&i.ApplicableCategories),
		&i.StartsAt,
		&i.ExpiresAt,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countOrderItemsByProductID = `-- name: CountOrderItemsByProductID :one
SELECT COUNT(*) FROM order_items oi
JOIN variants v ON oi.variant_id = v.id
WHERE v.product_id = $1::bigint
`

func (q *Queries) CountOrderItemsByProductID(ctx context.Context, productID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOrderItemsByProductID, productID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteProductPrices = `-- name: DeleteProductPrices :exec
DELETE FROM prices WHERE variant_id IN (SELECT id FROM variants WHERE product_id = $1::bigint)
`

func (q *Queries) DeleteProductPrices(ctx context.Context, productID string) error {
	_, err := q.db.ExecContext(ctx, deleteProductPrices, productID)
	return err
}

const deleteProductVariants = `-- name: DeleteProductVariants :exec
DELETE FROM variants WHERE product_id = $1::bigint
`

func (q *Queries) DeleteProductVariants(ctx context.Context, productID string) error {
	_, err := q.db.ExecContext(ctx, deleteProductVariants, productID)
	return err
}

const deleteProductImagesByProductID = `-- name: DeleteProductImagesByProductID :exec
DELETE FROM product_images WHERE product_id = $1::bigint
`

func (q *Queries) DeleteProductImagesByProductID(ctx context.Context, productID string) error {
	_, err := q.db.ExecContext(ctx, deleteProductImagesByProductID, productID)
	return err
}
